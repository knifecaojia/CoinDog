import numpy as np
import pandas as pa
import json
import time
import copy
import threading
import traceback
exchangesnamelist=[]
exchangespairlnamelist=[]#交易市场对儿
exchangesdf=pa.DataFrame()
exchangesdiffdf=pa.DataFrame()
tradetasklistdf=pa.DataFrame()
exchangesdfcolumnsname=["Name","Delay","Buy","Sell","Balance","Stocks","FrozenBalance","FrozenStocks","InitBalance","InitStocks","InitNET","NET","Profit"]
exchangesdfcolumnsnameshow=["名字","延时","买","卖","现金","货币","冻金","冻币","初金","初币","初资产","现资产","浮盈"]
starttime=0#策略开始时间
exchangesdiffcolumnsname=["KeyName","ABuy","ASell","BBuy","BSell","InDiff","OutDiff","InMax","OutMin","InAvg","OutAvg","Go"]
exchangesdiffcolumnsnameshow=["交易对","左买","左卖","右买","右卖","进差","出差","进最大","出最小","进平均","出平均","信号"]

tradetasklistcolumnsname=["KeyName","Ae","Be","Status","ABuy","ASell","BBuy","BSell","InBuy","InSell","OutBuy","OutSell","Profit","CompleteCount"]
tradetasklistcolumnsnameshow=["交易对","左","右","左买","左卖","右买","右卖","状态","进买","进卖","出买","出卖","盈利","次数"]

histradelistcolumnsnameshow=["左","右","进","出","进买价","进买量","进卖价","进卖量","出买价","出买量","出卖价","出卖量","进盈利","出盈利","净盈利"]
histradelist=[]
tradinglist={} #保存当前正在进行的进场交易
EMPair={}
tradepairdict={}
Status={"up":[],"tables":[],"bottom":[]}
def init():#初始化 完成多个df 表格的格式化工作，该方案导致无法重复进场
    SetErrorFilter("GetAccount|GetDepth|GetTicker|GetRecords|GetTrades|GetOrders|SetContractType")
    LogReset()
    LogProfitReset()
    starttime=time.time()
    exchangesnamelist = [_C(e.GetName) for e in exchanges] #取得交易所名称列表
    for i in exchangesnamelist:
        for j in exchangesnamelist:
            if i!=j:
                keyname=i+":"+j
                exchangespairlnamelist.append(i+":"+j)
                EMPair[keyname]={"InDiffPrice":[],"OutDiffPrice":[],"TradePair":{"InDiffPrice":0,"InAmount":0,"InFee":0}}

    exchangesdf=pa.DataFrame(columns=exchangesdfcolumnsname,index=exchangesnamelist)
    exchangesdiffdf=pa.DataFrame(columns=exchangesdiffcolumnsname,index=exchangespairlnamelist)
    tradetasklistdf=pa.DataFrame(columns=tradetasklistcolumnsname,index=exchangespairlnamelist)
    tradetasklistdf.append(exchangespairlnamelist)
    tradetasklistdf=tradetasklistdf.fillna(value=0)
def GetHisTable():
    str={'type': 'table', 'title': '历史记录', 'cols': [],'rows':[]}
    str["cols"]=histradelistcolumnsnameshow 
    rows=[]
    for i in range(len(histradelist)):
        row=[]
        row.append(histradelist[i].AeName)
        row.append(histradelist[i].BeName)
        row.append(_D(histradelist[i].InTime))
        row.append(_D(histradelist[i].OutTime))

        row.append(round(histradelist[i].InBuyPrice,2))
        row.append(round(histradelist[i].InBuyAmount,2))
        row.append(round(histradelist[i].InSellPrice,2))
        row.append(round(histradelist[i].InSellAmount,2))
        row.append(round(histradelist[i].OutBuyPrice,2))
        row.append(round(histradelist[i].OutBuyAmount,2))
        row.append(round(histradelist[i].OutSellPrice,2))
        row.append(round(histradelist[i].OutSellAmount,2))
        row.append(round(histradelist[i].InProfit,2))
        row.append(round(histradelist[i].OutProfit,2))
        row.append(round(histradelist[i].Profit,2))
        rows.append(row)    
    str["rows"]=rows
    return str
def GetInFieldTable():
    str={'type': 'table', 'title': '在场监控', 'cols': [],'rows':[]}
    str["cols"]=histradelistcolumnsnameshow 
    rows=[]
    for i in tradinglist:
        row=[]
        row.append(tradinglist[i].AeName)
        row.append(tradinglist[i].BeName)
        row.append(_D(tradinglist[i].InTime))
        if tradinglist[i].OutTime>0:
            row.append(_D(tradinglist[i].OutTime))
        else:
            row.append(tradinglist[i].OutTime)
        row.append(tradinglist[i].InBuyPrice)
        row.append(tradinglist[i].InBuyAmount)
        row.append(tradinglist[i].InSellPrice)
        row.append(tradinglist[i].InSellAmount)
        row.append(tradinglist[i].OutBuyPrice)
        row.append(tradinglist[i].OutBuyAmount)
        row.append(tradinglist[i].OutSellPrice)
        row.append(tradinglist[i].OutSellAmount)
        row.append(tradinglist[i].InProfit)
        row.append(tradinglist[i].OutProfit)
        row.append(tradinglist[i].Profit)
        rows.append(row)    
    str["rows"]=rows
    return str
def main():

    runtime=0
    Log("系统启动，初始化市场...")
    em=ExchangeManage()
    while abs(em.NETDiff)<abs(MaxLost):#双向终止操作，盈利和损失都计入
        runtime+=1
        Status["bottom"]=[]
        Status["up"]=[]
        Status["tables"]=[]
        try:
            times=time.time()
            em.Update() 
            timeet=time.time()
            if runtime>100:
                em.CheckOut()
                em.CheckIn()
       
        
      
            timee=time.time()
            Status["up"].append(em.GetAdvExcInfo())
            Status["bottom"].append("访问次数:"+str(em.UpdateTime))
            Status["tables"].append(ext.GetTableDict(exchangesdf,"交易所",exchangesdfcolumnsnameshow))
            Status["tables"].append(ext.GetTableDict(exchangesdiffdf,"信号监控",exchangesdiffcolumnsnameshow))
            Status["tables"].append(ext.GetTableDict(tradetasklistdf,"交易监控",tradetasklistcolumnsnameshow))
            Status["tables"].append(GetInFieldTable())
            Status["tables"].append(GetHisTable())
       
            timeeu=time.time()
            TDelay=int((timeet-times)*1000)#取得更新延迟
            TDelayT=int((timee-timeet)*1000)#取得交易延迟
            TDelayU=int((timeeu-timee)*1000)#取得交易延迟
            Status["bottom"].append("发起更新时间:"+time.strftime("%Y-%m-%d %X", time.localtime(times))+" 更新延迟:"+str(TDelay)+"ms"+" 交易延迟:"+str(TDelayT)+"ms"+" 显示延迟:"+str(TDelayU)+"ms")
            LogStatus(ext.GetStrFromList(Status["up"]),'\n`'+json.dumps(Status["tables"])+'`\n',ext.GetStrFromList(Status["bottom"]))
        except Exception,e:  
            Log("err:",e,traceback.print_exc())
        Sleep(300)
    if em.NETDiff>0:
        Log("系统判断止盈终止条件，结束交易...@")
    else:
        Log("系统判断止损终止条件，结束交易...@")

class TradePair:
    def __init__(self):
        self.AeName=""
        self.BeName=""
        self.InTime=0
        self.OutTime=0
        self.InSellPrice=0
        self.InBuyPrice=0
        self.InSellAmount=0
        self.InBuyAmount=0
        self.InFee=0
        self.InProfit=0
        self.OutSellPrice=0
        self.OutBuyPrice=0
        self.OutSellAmount=0
        self.OutBuyAmount=0
        self.OutFee=0
        self.OutProfit=0
        self.Profit=0
        self.InDiffPrice=0
        self.OutDiffPrice=0
        self.InSellCheck=False
        self.InBuyCheck=False
        self.OutSellCheck=False
        self.OutBuyCheck=False
class ExchangeManage:
    def __init__(self):
        self.EM={}
        self.UpdateTime=1
        self.exchangenames=[]
        self.EMPair={}
        self.TotalInAmount=0
        self.Profit=0
        self.NETDiff=0
        self.TotalFee=0
        self.NoOpNET=0#无操作 
        for i in range(len(exchanges)):
            ex=AdvExchange(exchanges[i])
            self.EM[ex.Name]=ex
            self.exchangenames.append(ex.Name)
    def Update(self):
        threadpool=[]
        for (d,x) in self.EM.items():
            t=threading.Thread(target=x.UpdateDepth,name=x.Name,args=(self.UpdateTime,))
            threadpool.append(t)
        for t in threadpool:
            t.start()
        for t in threadpool:
            t.join()
        #for (d,x) in self.EM.items():
        #    self.EM[d].UpdateDepth(self.UpdateTime)
        self.UpdateTime+=1
        self.GetExchangeDiff()
    def GetExchangeDiff(self):           
        for i in self.EM:
            InDiffPrice = 0
            InMax = InDiffPrice
            InAvg = InDiffPrice
            OutMin = InDiffPrice
            OutAvg = InDiffPrice
            Ins = InDiffPrice
            Outs = InDiffPrice
            ABuy=0
            ASell=0
            BBuy=0
            BSell=0
            Go=0
            for j in self.EM:
                if i != j:
                    keyname = self.EM[i].Name + ":" + self.EM[j].Name
                    InDiffPrice = ext.Cut((self.EM[i].Buy.Price - self.EM[j].Sell.Price),3)  # 进场差价 在高价市场卖出，在低价市场买入 对应A B市场，A->B 进场 A卖出 B买入
                    OutDiffPrice = ext.Cut((self.EM[j].Buy.Price-self.EM[i].Sell.Price),3)    # 出场差价 A买入 B卖出
                    InAmount = self.EM[i].Buy.Amount#进场量
                    OutAmount = self.EM[j].Buy.Amount#出场量
                    ABuy=self.EM[i].Buy.Price
                    ASell=self.EM[i].Sell.Price
                    BBuy=self.EM[j].Buy.Price
                    BSell=self.EM[j].Sell.Price
                    if self.UpdateTime<2 :
                        InMax = InDiffPrice                     
                        InAvg = InDiffPrice                   
                        OutMin = InDiffPrice
                        OutAvg = InDiffPrice
                        Ins = InDiffPrice
                        Outs = InDiffPrice
                        Go=0
                    else:
                        # Log(LDF)
                        div=self.UpdateTime
                        if self.UpdateTime<WatchWindow:
                            EMPair[keyname]["InDiffPrice"].append(InDiffPrice)
                            EMPair[keyname]["OutDiffPrice"].append(OutDiffPrice)
                        else:
                            div=WatchWindow
                            EMPair[keyname]["InDiffPrice"]=copy.copy(EMPair[keyname]["InDiffPrice"][1:])
                            EMPair[keyname]["OutDiffPrice"]=copy.copy(EMPair[keyname]["OutDiffPrice"][1:])
                            EMPair[keyname]["InDiffPrice"].append(InDiffPrice)
                            EMPair[keyname]["OutDiffPrice"].append(OutDiffPrice)                            
                        InMax =  max(EMPair[keyname]["InDiffPrice"])                                           
                        OutMin =  min(EMPair[keyname]["OutDiffPrice"])    
                        InAvg = ext.Cut((sum(EMPair[keyname]["InDiffPrice"]) / div),2)
                        OutAvg = ext.Cut((sum(EMPair[keyname]["OutDiffPrice"])/ div),2)
                        Ins = ext.Cut((InMax+InAvg)/InST,2) #根据进场门限设定进场信号门限 
                        if (InDiffPrice>0 and (InDiffPrice-OutMin>0)):
                            Go=ext.Cut(((InDiffPrice-Ins)*(InDiffPrice-OutMin)),3)                          
                        else:
                            Go=0
                        if Go<0:
                            Go=0
                    exchangesdiffdf.ix[keyname, 'KeyName'] = keyname
                    exchangesdiffdf.ix[keyname, 'ABuy'] = ABuy
                    exchangesdiffdf.ix[keyname, 'ASell'] = ASell
                    exchangesdiffdf.ix[keyname, 'BBuy'] = BBuy
                    exchangesdiffdf.ix[keyname, 'BSell'] = BSell
                    exchangesdiffdf.ix[keyname, 'InDiff'] = InDiffPrice
                    exchangesdiffdf.ix[keyname, 'OutDiff'] = OutDiffPrice
                    exchangesdiffdf.ix[keyname, 'InMax'] = InMax
                    exchangesdiffdf.ix[keyname, 'OutMin'] = OutMin
                    exchangesdiffdf.ix[keyname, 'InAvg'] = InAvg
                    exchangesdiffdf.ix[keyname, 'OutAvg'] = OutAvg
                    exchangesdiffdf.ix[keyname, 'GO'] = Go
                    
                    
                    tradetasklistdf.ix[keyname,"KeyName"]=keyname
                    tradetasklistdf.ix[keyname,"Ae"]=self.EM[i].Name+":"+str(self.EM[i].GetDepthDelay)
                    tradetasklistdf.ix[keyname,"Be"]=self.EM[j].Name+":"+str(self.EM[j].GetDepthDelay)
                  
                    tradetasklistdf.ix[keyname,"ABuy"]=self.EM[i].Buy.Price
                    tradetasklistdf.ix[keyname,"ASell"]=self.EM[i].Sell.Price
                    tradetasklistdf.ix[keyname,"BBuy"]=self.EM[j].Buy.Price
                    tradetasklistdf.ix[keyname,"BSell"]=self.EM[i].Sell.Price
                    if self.UpdateTime<3:
                        tradetasklistdf.ix[keyname,"Status"]="waiting in"
                        tradetasklistdf.ix[keyname,"InBuy"]="--"
                        tradetasklistdf.ix[keyname,"InSell"]="--"
                        tradetasklistdf.ix[keyname,"OutBuy"]="--"
                        tradetasklistdf.ix[keyname,"OutSell"]="--"
                        tradetasklistdf.ix[keyname,"Profit"]=0                    
                        tradetasklistdf.ix[keyname,"CompleteCount"]=0
    def CheckOut(self):#出场检测
        df=tradetasklistdf.ix[tradetasklistdf["Status"]=="waiting out"]      
        if df is not None and len(df.index)>0:          
            keyname=df.ix[0, 'KeyName']
            i=keyname.split(":")[0]
            j=keyname.split(":")[1]
            InDiffPrice=tradinglist[keyname].InDiffPrice
            if tradinglist[keyname].OutDiffPrice==0:
                tradinglist[keyname].OutDiffPrice=exchangesdiffdf.ix[keyname, 'OutDiff']
            OutDiffPrice=exchangesdiffdf.ix[keyname, 'OutDiff'] #获得出场价差
            MayOutFee=MaxCoinOnce*self.EM[i].Sell.Price*self.EM[i].Fee.Sell/100+MaxCoinOnce*self.EM[j].Buy.Price*self.EM[j].Fee.Buy/100
            MayOutProfit=OutDiffPrice*MaxCoinOnce*(1-self.EM[i].Fee.Buy/100)*(1-self.EM[j].Fee.Sell/100)-MayOutFee
            #Log("INS:",tradinglist[keyname].InSellPrice,"INB",tradinglist[keyname].InBuyPrice,"InDiffPrice:",InDiffPrice,"OutDiffPrice:",OutDiffPrice,"MayOutProfit:",MayOutProfit)
            if tradinglist[keyname].InProfit+MayOutProfit>0.5:#总盈利大于5毛就搞
                #Log("InProfit",tradinglist[keyname].InProfit,"MayOutProfit",MayOutProfit,"能出场了，搞之")
                AlreadyOutSellAmount=tradinglist[keyname].OutSellAmount #取得已出场数额
                AlreadyOutSellPrice=tradinglist[keyname].OutSellPrice #取得出场卖价
                AlreadyOutBuyAmount=tradinglist[keyname].OutBuyAmount#取得已出场买入数额
                AlreadyOutBuyPrice=tradinglist[keyname].OutBuyPrice #取得出场买入价格           
                DiffOutSellAmount=round((MaxCoinOnce-AlreadyOutSellAmount),1) #出场卖出需要的数量
                DiffOutBuyAmount=round((MaxCoinOnce-AlreadyOutBuyAmount),1) #出场买入需要的数量
                if tradinglist[keyname].OutDiffPrice==0:
                    tradinglist[keyname].OutDiffPrice=OutDiffPrice
                noweastocks=self.EM[i].Stocks
                nowebstocks=self.EM[j].Stocks#交易前两个市场的币
                InAmount=self.EM[j].Buy.Amount  
                OutBuyAmount=self.EM[i].Sell.Amount
                
                SellErrstr=""
                SellAmount=min(DiffOutSellAmount,InAmount)
                if self.EM[j].Stocks<SellAmount:
                    SellErrstr+="【缺币啦】市场:"+self.EM[j].Name
                if AlreadyOutSellPrice>0 and self.EM[j].Buy.Price<AlreadyOutSellPrice:
                    SellErrstr+="出场卖价小于已入场卖价！"
                
                BuyErrstr=""
                BuyAmount=min(DiffOutBuyAmount,OutBuyAmount)
                canbyamount=ext.Cut(self.EM[i].Balance/self.EM[i].Sell.Price,4)
                if canbyamount<BuyAmount:
                     BuyErrstr+="【缺钱啦】市场:"+self.EM[i].Name
                if AlreadyOutBuyPrice>0 and self.EM[i].Sell.Price>AlreadyOutBuyPrice:
                     BuyErrstr+="出场买价大于已入场买价！"
                                
                noweastocks=self.EM[i].Stocks
                nowebstocks=self.EM[j].Stocks#交易前两个市场的币
                
                 #如果通过了检查 则进行交易
                if len(SellErrstr)==0 and SellAmount>0:
                    Log("准备【出场-卖出】市场：",self.EM[j].Name,"Sell At:",self.EM[j].Buy.Price,"Amount:",SellAmount)
                    self.EM[j].e.Sell(self.EM[j].Buy.Price,SellAmount)
                 
                if len(BuyErrstr)==0 and BuyAmount>0:
                    #self.EM[i].e.Buy(self.EM[i].Sell.Price,BuyAmount/(1-self.EM[i].Fee.Buy/100))
                    self.EM[i].e.Buy(self.EM[i].Sell.Price,BuyAmount/(1-self.EM[i].Fee.Buy/98))
                  
                #休眠100毫秒 
                Sleep(100)
                # 检查账户成交                
                eatradeamount=ebtradeamount=0
                if len(SellErrstr)==0 and SellAmount>0:
                    self.EM[j].UpdateAccout()
                    while self.EM[j].FrozenStocks>0 or self.EM[j].FrozenBalance>0:#存在卖出不成交的情况 
                        Log("FrozenBalance:",self.EM[j].FrozenBalance,"FrozenStocks:",self.EM[j].FrozenStocks)
                        #Log("FrozenStocks:",self.EM[j].FrozenStocks)
                        self.EM[j].cancelAll()
                        self.EM[j].UpdateAccout()
                    ebtradeamount=round((nowebstocks-self.EM[j].Stocks-self.EM[j].FrozenStocks),2) #成交数量  
                    Log("检查【出场-卖出】原币数",nowebstocks,"当前币数",self.EM[j].Stocks,"成交数",ebtradeamount)
                    if ebtradeamount<0:
                        ebtradeamount=0
                    if(ebtradeamount+tradinglist[keyname].OutSellAmount)>0:
                        tradinglist[keyname].OutSellPrice=round(((tradinglist[keyname].OutSellAmount*tradinglist[keyname].OutSellPrice+ebtradeamount*self.EM[j].Buy.Price)/(tradinglist[keyname].OutSellAmount+ebtradeamount)),2)
                    tradinglist[keyname].OutSellAmount=round(tradinglist[keyname].OutSellAmount+ebtradeamount,1)                   
                    
                
                if len(BuyErrstr)==0 and BuyAmount>0:

                    self.EM[i].UpdateAccout()
                    while self.EM[i].FrozenBalance>0 or self.EM[i].FrozenStocks>0:
                        Log("FrozenBalance:",self.EM[i].FrozenBalance,"FrozenStocks:",self.EM[i].FrozenStocks)
                        #Log("FrozenBalance:",self.EM[j].FrozenBalance)
                        self.EM[i].cancelAll()
                        self.EM[i].UpdateAccout()
                    eatradeamount=self.EM[i].Stocks-noweastocks #成交数量
                    if  eatradeamount<0:
                        eatradeamount=0
                    if(eatradeamount+tradinglist[keyname].OutBuyAmount)>0:
                        tradinglist[keyname].OutBuyPrice=round(((tradinglist[keyname].OutBuyAmount*tradinglist[keyname].OutBuyPrice+eatradeamount*self.EM[i].Sell.Price)/(tradinglist[keyname].OutBuyAmount+eatradeamount)),2)
                    tradinglist[keyname].OutBuyAmount=round(tradinglist[keyname].OutBuyAmount+eatradeamount,1)
               
                if tradinglist[keyname].OutSellAmount<MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"OutSell"]="in"
                elif tradinglist[keyname].OutSellAmount==MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"OutSell"]="ok"
                if tradinglist[keyname].OutBuyAmount<MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"OutBuy"]="in"
                elif tradinglist[keyname].OutBuyAmount==MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"OutBuy"]="ok"                  
                

             
                if tradinglist[keyname].OutSellAmount==MaxCoinOnce and tradinglist[keyname].OutBuyAmount==MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"Status"]="waiting in"
                    fee=(tradinglist[keyname].OutSellAmount*tradinglist[keyname].OutSellPrice)*self.EM[j].Fee.Sell/100+ tradinglist[keyname].OutBuyPrice*( tradinglist[keyname].OutBuyAmount/(1-self.EM[i].Fee.Buy))*self.EM[i].Fee.Buy/100
                    tradinglist[keyname].OutFee=ext.Cut(fee,4)
                    tradinglist[keyname].OutProfit=tradinglist[keyname].OutSellPrice*tradinglist[keyname].OutSellAmount-tradinglist[keyname].OutBuyPrice*tradinglist[keyname].OutBuyAmount-tradinglist[keyname].OutFee
                    tradinglist[keyname].OutProfit=ext.Cut(tradinglist[keyname].OutProfit,2)
                    tradinglist[keyname].Profit= tradinglist[keyname].InProfit+ tradinglist[keyname].OutProfit
                    self.Profit+=tradinglist[keyname].Profit
                    LogProfit(self.Profit)
                    Log("盈利:",ext.Cut(self.Profit,2),"@")
                    tradinglist[keyname].OutTime=time.time()
                    tradetasklistdf.ix[keyname,"Status"]="waiting in"
                    tradetasklistdf.ix[keyname,"InBuy"]="--"
                    tradetasklistdf.ix[keyname,"InSell"]="--"
                    tradetasklistdf.ix[keyname,"OutBuy"]="--"
                    tradetasklistdf.ix[keyname,"OutSell"]="--"
                    tradetasklistdf.ix[keyname,"Profit"]+=tradinglist[keyname].Profit                    
                    tradetasklistdf.ix[keyname,"CompleteCount"]+=1
                    histradelist.append(copy.copy(tradinglist[keyname]))
                    self.TotalFee+=tradinglist[keyname].InFee+tradinglist[keyname].OutFee
                    tradinglist[keyname].InTime=0
                    tradinglist[keyname].OutTime=0
                    tradinglist[keyname].InSellPrice=0
                    tradinglist[keyname].InBuyPrice=0
                    tradinglist[keyname].InSellAmount=0
                    tradinglist[keyname].InBuyAmount=0
                    tradinglist[keyname].InFee=0
                    tradinglist[keyname].InProfit=0
                    tradinglist[keyname].OutSellPrice=0
                    tradinglist[keyname].OutBuyPrice=0
                    tradinglist[keyname].OutSellAmount=0
                    tradinglist[keyname].OutBuyAmount=0
                    tradinglist[keyname].OutFee=0
                    tradinglist[keyname].OutProfit=0
                    tradinglist[keyname].Profit=0
                    tradinglist[keyname].OutDiffPrice=0
                    tradinglist[keyname].InDiffPrice=0
                
                
    def CheckIn(self):#进场检测
        df=exchangesdiffdf.loc[exchangesdiffdf["GO"]>GoT] 
        #Log(df)
        if df is not None and len(df.index)>0:
            Go=df.head()['GO'].values            
            if len(Go)==0:
                return
            Go=Go[0]           
            keyname=df.ix[0, 'KeyName']
            i=keyname.split(":")[0]
            j=keyname.split(":")[1]
            InDiffPrice=df.ix[0, 'InDiff']
            if InDiffPrice<MaxCoinOnce*0.008*self.EM[i].Buy.Price:#进场差价太小
                #Log("进场差价倒挂:",InDiffPrice)
                return
            OutAvg=df.ix[0, 'OutAvg']
            #检测反向市场入场情况exchangesdiffdf
            if tradetasklistdf.loc[j+":"+i]["Status"]!="waiting in":
                #Log("存在反向在场交易对儿！滚！")
                return
            if not(keyname in tradinglist): #监控中的交易列表没有这个 就加上，属于新建
                tradinglist[keyname]=TradePair()                  
            if tradetasklistdf.loc[keyname]["Status"]=="waiting in" or tradetasklistdf.loc[keyname]["Status"]=="going in":#等待入场 或是 已完成部分入场          
                if tradetasklistdf.loc[keyname]["Status"]=="waiting in":
                    tradinglist[keyname].InDiffPrice=InDiffPrice
                    tradinglist[keyname].InTime=time.time()
                    tradetasklistdf.ix[keyname,"Status"]="going in"
                    tradinglist[keyname].AeName=i
                    tradinglist[keyname].BeName=j
                AlreadyInSellAmount=tradinglist[keyname].InSellAmount #取得已进场数额
                AlreadyInSellPrice=tradinglist[keyname].InSellPrice #取得进场卖价
                AlreadyInBuyAmount=tradinglist[keyname].InBuyAmount#取得已进场买入数额
                AlreadyInBuyPrice=tradinglist[keyname].InBuyPrice #取得进场买入价格           
                DiffInSellAmount=round((MaxCoinOnce-AlreadyInSellAmount),1) #进场卖出需要的数量
                DiffInBuyAmount=round((MaxCoinOnce-AlreadyInBuyAmount),1) #进场买入需要的数量
                InAmount=self.EM[i].Buy.Amount   #Ea 市场买入份额，高价卖出对应的市场深度
                OutBuyAmount=self.EM[j].Sell.Amount #Eb 市场卖出的份额，低价买入对应的市场深度
                
                SellErrstr=""
                SellAmount=min(DiffInSellAmount,InAmount)
                if self.EM[i].Stocks<SellAmount:
                    SellErrstr+="【缺币啦】市场:"+self.EM[i].Name
                if AlreadyInSellPrice>0 and self.EM[i].Buy.Price<AlreadyInSellPrice:
                    SellErrstr+="入场卖价小于已入场卖价！"
                
                BuyErrstr=""
                BuyAmount=min(DiffInBuyAmount,OutBuyAmount)
                canbyamount=ext.Cut(self.EM[j].Balance/self.EM[j].Sell.Price,4)
                if canbyamount<BuyAmount:
                     BuyErrstr+="【缺钱啦】市场:"+self.EM[j].Name
                if AlreadyInBuyPrice>0 and self.EM[j].Sell.Price>AlreadyInBuyPrice:
                     BuyErrstr+="入场买价大于已入场买价！"
                                
                noweastocks=self.EM[i].Stocks
                nowebstocks=self.EM[j].Stocks#交易前两个市场的币

                #如果通过了检查 则进行交易
                if len(SellErrstr)==0 and SellAmount>0:
                    self.EM[i].e.Sell(self.EM[i].Buy.Price,SellAmount)
                 
                if len(BuyErrstr)==0 and BuyAmount>0:
                    #self.EM[j].e.Buy(self.EM[j].Sell.Price,BuyAmount/(1-self.EM[j].Fee.Buy/100))
                    self.EM[j].e.Buy(self.EM[j].Sell.Price,BuyAmount/(1-self.EM[j].Fee.Buy/98))
                #休眠100毫秒 
                Sleep(100)
                # 检查账户成交
                eatradeamount=ebtradeamount=0
                if len(SellErrstr)==0 and SellAmount>0:
                    self.EM[i].UpdateAccout()
                    while self.EM[i].FrozenStocks>0 or self.EM[i].FrozenBalance>0:#存在卖出不成交的情况 
                        Log("FrozenBalance:",self.EM[i].FrozenBalance,"FrozenStocks:",self.EM[i].FrozenStocks)
                        self.EM[i].cancelAll()
                        self.EM[i].UpdateAccout()
                    eatradeamount=noweastocks-self.EM[i].Stocks-self.EM[i].FrozenStocks #成交数量
                    if  eatradeamount<0:
                        eatradeamount=0
                    if(eatradeamount+tradinglist[keyname].InSellAmount)>0:
                        tradinglist[keyname].InSellPrice=round(((tradinglist[keyname].InSellAmount*tradinglist[keyname].InSellPrice+eatradeamount*self.EM[i].Buy.Price)/(tradinglist[keyname].InSellAmount+eatradeamount)),2)
                    tradinglist[keyname].InSellAmount=round(tradinglist[keyname].InSellAmount+eatradeamount,1)
                    
                
                if len(BuyErrstr)==0 and BuyAmount>0:
                    self.EM[j].UpdateAccout()
                    while self.EM[j].FrozenBalance>0 or self.EM[j].FrozenStocks>0:
                        Log("FrozenBalance:",self.EM[j].FrozenBalance,"FrozenStocks:",self.EM[j].FrozenStocks)
                        self.EM[j].cancelAll()
                        self.EM[j].UpdateAccout()
                    ebtradeamount=round((self.EM[j].Stocks-nowebstocks),2) #成交数量  
                    Log("nowebstocks",nowebstocks,"Stocks",self.EM[j].Stocks,"ebtradeamount",ebtradeamount)
                    if ebtradeamount<0:
                        ebtradeamount=0
                    if(ebtradeamount+tradinglist[keyname].InBuyAmount)>0:
                        tradinglist[keyname].InBuyPrice=round(((tradinglist[keyname].InBuyAmount*tradinglist[keyname].InBuyPrice+ebtradeamount*self.EM[j].Sell.Price)/(tradinglist[keyname].InBuyAmount+ebtradeamount)),2)
                    tradinglist[keyname].InBuyAmount=round(tradinglist[keyname].InBuyAmount+ebtradeamount,1)
                    
               
                if tradinglist[keyname].InSellAmount<MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"InSell"]="in"
                elif tradinglist[keyname].InSellAmount==MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"InSell"]="ok"
                if tradinglist[keyname].InBuyAmount<MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"InBuy"]="in"
                elif tradinglist[keyname].InSellAmount==MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"InBuy"]="ok"                  
                fee=(tradinglist[keyname].InSellAmount*tradinglist[keyname].InSellPrice)*self.EM[i].Fee.Sell/100+ tradinglist[keyname].InBuyPrice*(tradinglist[keyname].InBuyAmount/(1-self.EM[j].Fee.Buy))*self.EM[j].Fee.Buy/100
                tradinglist[keyname].InFee=ext.Cut(fee,4)
                tradinglist[keyname].InProfit=tradinglist[keyname].InSellPrice*tradinglist[keyname].InSellAmount-tradinglist[keyname].InBuyPrice*tradinglist[keyname].InBuyAmount-tradinglist[keyname].InFee
                tradinglist[keyname].InProfit=ext.Cut(tradinglist[keyname].InProfit,2)
               
               
                if tradinglist[keyname].InSellAmount==MaxCoinOnce and tradinglist[keyname].InBuyAmount==MaxCoinOnce:
                    tradetasklistdf.ix[keyname,"Status"]="waiting out"


    

    def GetAdvExcInfo(self):
        _str=""
        totalexchange=0
        totalbalance=0
        totalstocks=0
        totalfrozenbalance=0
        totalfrozenstocks=0
        totalnet=0
        totalstartnet=0
        noopnet=0
        for i in self.EM:
            totalexchange+=1
            totalbalance+=self.EM[i].Balance
            totalstocks+=self.EM[i].Stocks
            totalfrozenbalance+=self.EM[i].FrozenBalance
            totalfrozenstocks+=self.EM[i].FrozenStocks
            totalnet+=self.EM[i].NET
            totalstartnet+=self.EM[i].InitNET
            noopnet+=self.EM[i].InitBalance+self.EM[i].InitFrozenBalance+(self.EM[i].InitStocks+self.EM[i].InitFrozenStocks)*self.EM[i].Buy.Price
        self.NoOpNET=ext.Cut((noopnet-totalstartnet),2)
        self.NETDiff=ext.Cut((totalnet-totalstartnet),2)
        _str="市场总数："+str(totalexchange)+" 总钱："+str(totalbalance)+" 总冻结钱："+str(totalfrozenbalance)+" 总币："+str(totalstocks)+" 总冻结币："+str(totalfrozenstocks)+" 总市值："+str(totalnet)+" 无操作浮盈:"+str(self.NoOpNET)+" 运行净值差:"+str(self.NETDiff)+" 总费:"+str(self.TotalFee)
        
        return _str
class AdvExchange:
    def __init__(self,exchange):
        self.e=exchange
        self.Name=self.e.GetName()
        self.SellList=[]
        self.BuyList=[]     
        times=time.time()
        self.Fee=self.e.GetFee()
        account=self.e.GetAccount()    
        self.InitBalance=ext.Cut(account.Balance,2)#初始账户现金余额
        self.InitFrozenBalance=ext.Cut(account.FrozenBalance,2)#初始账户现金冻结余额
        self.InitStocks=ext.Cut(account.Stocks,4)#初始账户币余额
        self.InitFrozenStocks=ext.Cut(account.FrozenStocks,4)#初始账户冻结币余额
        self.Balance=ext.Cut(account.Balance,2)#初始账户现金余额
        self.FrozenBalance=ext.Cut(account.FrozenBalance,2)#初始账户现金冻结余额
        self.Stocks=ext.Cut(account.Stocks,4)#初始账户币余额
        self.FrozenStocks=ext.Cut(account.FrozenStocks,4)#初始账户冻结币余额      
        timee=time.time()
        self.GetAccountDelay=int((timee-times)*1000)#取得账户信息延迟        
        times=time.time()
        depth=self.e.GetDepth()
        self.Sell=depth.Asks[0]
        self.SellList.append(depth.Asks[0])   
        self.Buy=depth.Bids[0]
        self.BuyList.append(depth.Bids[0])   
        self.InitPrice=self.Buy.Price#初始资产计算价格 取初始时 市场深度买一价格
        self.InitNET=ext.Cut((self.InitBalance+self.InitFrozenBalance+(self.InitStocks+self.InitFrozenStocks)*self.InitPrice),2)#初始净资产  
        self.NET=ext.Cut((self.Balance+self.FrozenBalance+(self.Stocks+self.FrozenStocks)*self.Buy.Price),2)
        timee=time.time()
        self.GetDepthDelay=int((timee-times)*1000)#取得深度信息延迟
        #self.Fee#初始化后交易总费用
        self.Delay=self.GetDepthDelay+self.GetAccountDelay       
        self.QueryFailedTimes=0#网络通信错误
        self.Profit=0#账户盈利     
        self.UpdateDf()
    #删除订单
    def cancelAll(self):
        ret = False
        while True:
            n = 0
            for order in _C(self.e.GetOrders):
                ret = True
                self.e.CancelOrder(order.Id)
                n+=1
            if n == 0:
                break
        return ret
    #更新深度信息           
    def UpdateDepth(self,updatetimes):
        times=time.time()   
        dwait=self.e.Go("GetDepth")  
        depth=dwait.wait()[0]  
        dtimee=time.time()     
        self.Sell=depth.Asks[0]
        self.Buy=depth.Bids[0]
        if updatetimes<WatchWindow:
            self.SellList.append(depth.Asks[0])          
            self.BuyList.append(depth.Bids[0]) 
        else:
            self.BuyList=copy.copy(self.BuyList[1:])
            self.SellList=copy.copy(self.SellList[1:]) 
            self.SellList.append(depth.Asks[0])          
            self.BuyList.append(depth.Bids[0]) 
        self.GetDepthDelay=int((dtimee-times)*1000)#取得深度信息延迟
        self.NET=ext.Cut((self.Balance+self.FrozenBalance+(self.Stocks+self.FrozenStocks)*self.Buy.Price),2)
        self.Profit=self.NET-self.InitNET#账户浮盈    
        self.UpdateDf()
    def UpdateAccout(self):
        times=time.time()
        await=self.e.Go("GetAccount")
        account=await.wait()[0]        
        atimee=time.time()        
        self.Balance=ext.Cut(account.Balance,2)#当前账户现金余额
        self.FrozenBalance=ext.Cut(account.FrozenBalance,2)#当前账户现金冻结余额
        self.Stocks=ext.Cut(account.Stocks,4)#当前账户币余额
        self.FrozenStocks=ext.Cut(account.FrozenStocks,4)#当前账户冻结币余额
        self.GetAccountDelay=int((atimee-times)*1000)#取得账户信息延迟
        self.UpdateDf()
    def UpdateDf(self):
        exchangesdf.ix[self.Name,'Name']=self.Name
        exchangesdf.ix[self.Name,'Delay']=str(self.Delay)+"("+str(self.GetAccountDelay)+":"+str(self.GetDepthDelay)+")"
        exchangesdf.ix[self.Name,'Buy']=self.Buy.Price
        exchangesdf.ix[self.Name,'Sell']=self.Sell.Price
        exchangesdf.ix[self.Name,'Balance']=self.Balance
        exchangesdf.ix[self.Name,'Stocks']=self.Stocks
        exchangesdf.ix[self.Name,'FrozenBalance']=self.FrozenBalance
        exchangesdf.ix[self.Name,'FrozenStocks']=self.FrozenStocks
        exchangesdf.ix[self.Name,'InitBalance']=self.InitBalance
        exchangesdf.ix[self.Name,'InitStocks']=self.InitStocks
        exchangesdf.ix[self.Name,'InitNET']=self.InitNET
        exchangesdf.ix[self.Name,'NET']=self.NET
        exchangesdf.ix[self.Name,'Profit']=self.Profit


